### 第一次提交
添加父工程pom
### 第二次提交
添加payment8001模块


### 第三次提交
+ 添加Order80模块，用来调用payment8001模块的接口
+ order80模块本身不连接数据库（在配置文件里不配置数据库连接），而是通过Springboot提供的restTemplate，通过http方式访问payment接口


### 第四次提交
+ 添加api-commons模块，存放一些通用的entity类（如Payment、CommonResult）
+ 执行maven-clean后，执行maven-install命令，将api-commons打包并装载到本地仓库，供其他模块声明引入
+ maven-install命令成功后，可以通过查看target\maven-archiver\pom.properties 获取api-commons jar包的在本地仓库的路径,比如:

```properties
#Generated by Maven
#Thu Jun 25 20:51:50 CST 2020
version=1.0-SNAPSHOT
groupId=org.manzuo
artifactId=cloud-api-commons

```


### 第五次提交
+ 添加eureka-server7001模块，用来作为一个服务注册中心
+ 通过在主启动类使用 `@EnableEurekaServer` 注解,声明该模块为服务注册中心
+ 服务注册中心模块需要引入以下依赖
```xml
    <!--eureka-server-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
        </dependency>
```
+ 通过在主启动类使用 `@EnableEurekaClient` 注解,声明该模块为服务提供者
+ 服务提供者模块需要引入以下依赖
```xml
        <!--eureka-client-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
``` 
+ 把payment8001模块、Order80模块作为服务注册在服务注册中心里


### 第六次提交
+ 添加eureka-server7002模块，构建eureka服务注册中心集群(相互注册,相互守望)
+ 为了在一台机器上搭建集群，我们可以修改hosts文件，配置多个域名映射本地ip
	+ hosts文件相关：
		+ hosts文件位置：
			+ window：C:\Windows\System32\drivers\etc
			+ liunx：/etc/hosts
		+ hosts文件作用：当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统再会将网址提交DNS域名解析服务器进行IP地址的解析
		+ 建议修改hosts文件前，先备份
+ 在hosts文件中添加下面几行代码
```
######## spring cloud 2020 ######
127.0.0.1       eureka7001.com
127.0.0.1       eureka7002.com
127.0.0.1       eureka7003.com
```
+ eureka集群之间可以相互复制注册信息,,所以原则上,服务提供者(或消费者)只需要向其中一个注册中心注册服务,集群里的其他注册中心也会有相应的注册信息
但是为了避免出现一个注册中心挂掉,服务提供者就无法注册服务的情况,服务提供者(或者消费者)最好同时向集群里的多个注册中心注册服务.
+ 复制payment8001模块,命名为payment8002,端口号改为8002,其他不变.即在服务注册中心注册了两个payment服务,实现了payment模块的集群
+ order80模块的请求url前缀改用payment服务的注册别名:`CLOUD-PAYMENT-SERVICE`,( String URL = "http://CLOUD-PAYMENT-SERVICE";), RestTemplate Bean加上`@LoadBalanced`开启RestTemplate负载均衡功能(默认是轮询的方式)


### 第七次提交:zookeeper相关

+ 新建payment8004模块，注册到zookeeper服务注册中心
+ zookeeper安装运行推荐使用docker,如下
```
#拉取镜像
docker pull zookeeper
#运行zookeeper容器
docker run -d --name myzookeeper -p 2181:2181 --restart always zookeeper
#进入zookeeper容器
docker exec -it myzookeeper /bin/bash
#（必须先进入zookeeper容器）连接zookeeper客户端
./bin/zkCli.sh
```
+ 新建cloud-consumerzk-order80模块，注册到zookeeper服务注册中心，并通过微服务名称调用payment8004模块接口
	+ (备注,cloud-consumerzk-order80模块和cloud-consumer-order80模块占用了同一个端口,不能同时启动)
### 第八次提交 Spring Cloud Ribbon相关
+ 简介：Ribbon可以提供客户端的软件负载均衡算法和服务调用
+ 负载均衡（Load Balance）：简单的说，将用户的请求平摊的分配到多个服务器上，从而达到系统的高可用
+ Ribbon本地负载均衡：在调用微服务接口的时候，会在注册中心获取到注册信息服务列表之后缓存到JVM本地，然后本地实现远程服务调用。
+ 和Nginx的区别：Nginx是服务器负载均衡，客户端所有请求都会交给Nginx，然后又Ngnix实现转发

+ 在Order80模块中新增了自定义的负载均衡规则类(myrule包下),并在主启动类中选择自定义的负载均衡规则类
    + 自定义的负载均衡规则类建议不要放在@ComponentScan注解可以扫描到的地方(@SpringBootApplication注解包含@ComponentScan注解)
    + 使用@RibbonClient选择自定义的负载均衡规则类
+ Order80模块中手写了一个轮询算法(lb包下):
    + 核心算法: 请求的次数 %服务器集群的总数 = 实际调用的服务器的下标
    + 请求的次数自增时采用cas自旋保证原子性
### 第九次提交 Spring Cloud OpenFeign相关
+ 新建cloud-consumer-feign-order80模块,集成openFeign
+ OpenFeign默认集成了Ribbon框架,默认实现了负载均衡功能
+ 实际上就是把 Ribbon+ RestTemplate 进一步封装成接口的方法,然后客户端通过调用接口的方法实现远程接口的调用
+ OpenFeign自带超时控制,接口方法调用时,默认只等待1s,超过1s会报错.如果方法调用超过1s,需要在配置文件配置.